

Code in this directory is used to process the data generated by scCAT-seq, C1 CAGE, BAT-seq, etc. Fastq file is needed and the output file format is "BED". Each Row represents read in corresponding position.

Then BED file as input is needed to call peak using CAGEr R package.

---

# Data processing for 5' data

The workflows of data of scCAT-seq 5', C1 CAGE, C1 STRT and Arguel et al. are similar. Here is the scCAT-seq 5' data processing workflow. To see detail imformation of other data processing, please see C1_CAGE_5_data_processing.sh, C1_STRT_5_data_processing.sh and Arguel_et_al_5_data_processing.sh.

## Preparation

Before process the data, we bulid some directory and move the script to "script_and_log" directory: 

```
mkdir ~/zjw/20190109
mkdir ~/zjw/20190109/5cap_read_with_tag
mkdir ~/zjw/20190109/trim_GTGGTATCAACGCAGAGTACAT
mkdir ~/zjw/20190109/mapping_output
mkdir ~/zjw/20190109/extract_uniquely_map
mkdir ~/zjw/20190109/split_plus_minus
mkdir ~/zjw/20190109/extract_mismatch
mkdir ~/zjw/20190109/final_out
mkdir ~/zjw/20190109/script_and_log
mv extractmismatch_plus_5'.py ~/zjw/20190109/script_and_log
mv extractmismatch_plus_3'.py ~/zjw/20190109/script_and_log
cd ~/zjw/20190109/script_and_log
```

Please make sure that fq files are list in `~/zjw/fastq_5cap_2018ab`. STAR index must be prepared before running this workflow. For build index, you can run:

```
STAR --runThreadN 24 --runMode genomeGenerate \
--genomeDir ~/index/mm10_STAR/ \
--genomeFastaFiles ~/index/mm10_chr/mm10.fa \
--sjdbGTFfile ~/index/mm10_chr/gencode.vM18.annotation.gtf \
--sjdbOverhang 150
```

## Find reads with TSO primer

Reads with TSO primer sequence at 5' are considered to further processing. TSO primer in scCAT-seq data is `GTGGTATCAACGCAGAGTACATGGG`.

```
for i in `ls ~/zjw/fastq_5cap_2018ab/`
do
        cat ~/zjw/fastq_5cap_2018ab/${i} | paste - - - - | grep $'\t'"${a}" | awk -v FS="\t" -v OFS="\n" '{print $1, $2, $3, $4}' > ~/zjw/20190109/5cap_read_with_tag/${i}_with_tag.fq
done
```

Output files are stored in `~/zjw/20190109/5cap_read_with_tag/`.

## Trim TSO primer but retain GGG

To trim TSO primer, we run:

```
for i in `ls ~/zjw/20190109/5cap_read_with_tag`
do
        cutadapt -g GTGGTATCAACGCAGAGTACAT -o ~/zjw/20190109/trim_GTGGTATCAACGCAGAGTACAT/${i}.trimed.remainGGG ~/zjw/20190109/5cap_read_with_tag/${i}
done
```

In this step, we trim TSO primer. However `GGG` at the end of TSO primer was retained for further filter. 

Output files are stored in `~/zjw/20190109/trim_GTGGTATCAACGCAGAGTACAT/`.

## Alignment

For alignment, we run:

```
for i in `ls ~/zjw/20190109/trim_GTGGTATCAACGCAGAGTACAT/`
do
        STAR --runThreadN 24 --genomeDir ~/index/mm10_ERCC92trimpolyA_STAR/ --genomeLoad LoadAndKeep --readFilesIn ~/zjw/20190109/trim_GTGGTATCAACGCAGAGTACAT/${i} --outFileNamePrefix ~/zjw/20190109/mapping_output/${i}_ --outSAMtype SAM --outFilterMultimapNmax 1 --outFilterScoreMinOverLread 0.6 --outFilterMatchNminOverLread 0.6
done
```

Output files are stored in `~/zjw/20190109/mapping_output/`

## Extract uniquely mapped reads

We only select uniquely mapped reads, so we run:

```
for i in `ls ~/zjw/20190109/mapping_output|grep "sam"`
do
        samtools view ~/zjw/20190109/mapping_output/${i} |grep 'NH:i:1'$'\t''' > ~/zjw/20190109/extract_uniquely_map/${i}_extract_uniquely_map.sam
done
```

Output files are stored in `~/zjw/20190109/extract_uniquely_map/`

## Split reads aligned to plus stand and minus strand

For further filter, we run:

```
for i in `ls ~/zjw/20190109/extract_uniquely_map | grep "sam"`
do
        cat ~/zjw/20190109/extract_uniquely_map/${i} | awk '{FS=" "}{if ($2==0 || $2==256){print $1"\t"$2"\t"$3"\t"$4"\t"$5"\t"$6"\t"$7"\t"$8"\t"$9"\t"$10"\t"$11"\t"$12"\t"$13"\t"$14"\t"$15}}' > ~/zjw/20190109/split_plus_minus/${i}_plus
        cat ~/zjw/20190109/extract_uniquely_map/${i} | awk '{FS=" "}{if ($2==16 || $2==272){print $1"\t"$2"\t"$3"\t"$4"\t"$5"\t"$6"\t"$7"\t"$8"\t"$9"\t"$10"\t"$11"\t"$12"\t"$13"\t"$14"\t"$15}}' > ~/zjw/20190109/split_plus_minus/${i}_minus
done
```

Output files are stored in `~/zjw/20190109/split_plus_minus/`

## Extract reads with mismatch at 5'

We run:

```
for i in `ls ~/zjw/20190109/split_plus_minus | grep "extract_uniquely_map.sam_plus"`
do
        python ~/zjw/20190109/script_and_log/extractmismatch_plus_5'.py -i ~/zjw/20190109/split_plus_minus/${i} -o ~/zjw/20190109/extract_mismatch/${i}_extractmismatch
        python ~/zjw/20190109/script_and_log/extractmismatch_minus_5'.py -i ~/zjw/20190109/split_plus_minus/${i%_*}_minus -o ~/zjw/20190109/extract_mismatch/${i%_*}_minus_extractmismatch
        #### combine together
        cat ~/zjw/20190109/extract_mismatch/${i}_extractmismatch ~/zjw/20190109/extract_mismatch/${i%_*}_minus_extractmismatch > ~/zjw/20190109/extract_mismatch/${i%_*}_extractmismatch
done
```

The template-switching (TS) oligonucleotide may hybridize to the first strand cDNA due to sequence complementarity before the RT has finished polymerizing. Artifact that introduced by incomplete reverse transcription process is called strand invasion. We suppose that if "GGG" aligned, reads are strand invasion drivern artifacts. If "GGG" don't aligned, reads are derived from complete reverse transcription.

Output files are stored in `~/zjw/20190109/extract_mismatch/`

## Convert SAM to BED

As BED format file can be used as input for CAGEr R package, we convert SAM to BED:

```
for i in `ls ~/zjw/20190109/extract_mismatch | grep "sam_extractmismatch"`
do
        samtools view -b -T ~/index/mm10_ERCC92/mm10_ERCC92trimpolyA.fa ~/zjw/20190109/extract_mismatch/${i} | samtools view -b >  ~/zjw/20190109/final_out/${i}_add_header.bam
        samtools sort ~/zjw/20190109/final_out/${i}_add_header.bam -o ~/zjw/20190109/final_out/${i}_add_header_sorted.bam
        samtools index ~/zjw/20190109/final_out/${i}_add_header_sorted.bam
        bedtools bamtobed -i ~/zjw/20190109/final_out/${i}_add_header_sorted.bam > ~/zjw/20190109/final_out/${i}_add_header_sorted.bed
done
```

Output files are stored in `~/zjw/20190109/final_out/`


## Remove useless end

As the library is pair-end reads, we remove one side which doesn't contain TSS information.

```
for i in `ls  ~/zjw/20190109/final_out |grep "bed"|grep "L1_1"`
do
        a=$(wc -l ~/zjw/20190109/final_out/${i}|awk '{print $1}')
        b=$(wc -l ~/zjw/20190109/final_out/${i%%L1_1*}L1_2.fq_with_tag.fq.trimed.remainGGG_Aligned.out.sam_extract_uniquely_map.sam_extractmismatch_add_header_sorted.bed|awk '{print $1}')
        echo ${a}
        echo ${b}
        if [ ${a} -gt ${b} ]; then
                rm ~/zjw/20190109/final_out/${i%%L1_1*}L1_2*
        else
                rm ~/zjw/20190109/final_out/${i%%L1_1*}L1_1*
        fi
done
```



---




# Data processing for 3' data

The workflows of data of scCAT-seq 3' and BAT-seq are similar. Here is the scCAT-seq 5' data processing workflow. To see detail imformation of BAT-seq data processing, please see BAT-seq_3_data_processing.sh.

## Preparation

Before process the data, we bulid some directory and move the script to "script_and_log" directory:

```
mkdir ~/zjw/20190105
mkdir ~/zjw/20190105/3tail_read_with_tag
mkdir ~/zjw/20190105/3tail_read_with_tag_other_strand
mkdir ~/zjw/20190105/3tail_read_with_tag_other_strand_withA10_remain_A5
mkdir ~/zjw/20190105/mapping_output
mkdir ~/zjw/20190105/extract_uniquely_map
mkdir ~/zjw/20190105/split_plus_minus
mkdir ~/zjw/20190105/extract_mismatch
mkdir ~/zjw/20190105/add_header
mkdir ~/zjw/20190105/script_and_log
mv extractmismatch_plus_3'.py ~/zjw/20190105/script_and_log
mv extractmismatch_minus_3'.py ~/zjw/20190105/script_and_log
mv sample_list_tag.txt ~/zjw/20190105/script_and_log
mv cmpfastq_pe.pl ~/zjw/20190105/script_and_log
cd ~/zjw/20190105/script_and_log
```

## Find reads with oligo(dT) primer

Reads with oligo(dT) primer sequence at 5'. We define reads with oligo(dT) primer sequence at 5' as R1 reads:

```
for i in `ls ~/zjw/fastq_5cap_2018ab`
do
a=$(grep "${i}" ~/zjw/20190105/script_and_log/sample_list_tag.txt|awk '{print $2}')
if [[ ${a} =~ "4" ]]; then
        b=${a#*4}
        echo ${b}
        echo "GTGGTATCAACGCAGAGT....${b%%TTTTTTTTTTTTTTTTTTTT*}"
        cat ~/zjw/fastq_5cap_2018ab/${i} | paste - - - - | grep "${b%%TTTTT*}TTTTT" | awk -v FS="\t" -v OFS="\n" '{print $1, $2, $3, $4}' > ~/zjw/20190105/3tail_read_with_tag/${i}_with_tag
fi
done
```

Output files are stored in `~/zjw/20190105/3tail_read_with_tag/`.

## Find R2 reads

Perl script cmpfastq_pe.pl is used to find R2 reads which its corresponding R1 reads with oligo(dT) primes:

```
for i in `ls ~/zjw/20190105/3tail_read_with_tag/ | grep "L1_1.fq_with_tag$"`
do
        perl cmpfastq_pe.pl ~/zjw/20190105/3tail_read_with_tag/${i} ~/zjw/fastq_5cap_2018ab/${i%_1*}_2.fq
done

for i in `ls ~/zjw/20190105/3tail_read_with_tag/ | grep "L1_2.fq_with_tag$"`
do
        perl cmpfastq_pe.pl ~/zjw/20190105/3tail_read_with_tag/${i} ~/zjw/fastq_5cap_2018ab/${i%_2*}_1.fq
done

rm ~/zjw/20190105/3tail_read_with_tag/*out
rm ~/zjw/fastq_5cap_2018ab/*unique.out
mv ~/zjw/fastq_5cap_2018ab/*out ~/zjw/20190105/3tail_read_with_tag_other_strand/
```

Output files are stored in `~/zjw/20190105/3tail_read_with_tag_other_strand/`.

## Trim A10 but retain A5 at R2 reads

To trim oligo(dT) primer, we run:

```
for i in `ls ~/zjw/20190105/3tail_read_with_tag_other_strand`
do
        python ~/zjw/20190105/script_and_log/find_A10_and_remain_A5.py  -i ~/zjw/20190105/3tail_read_with_tag_other_strand/${i} -o ~/zjw/20190105/3tail_read_with_tag_other_strand_withA10_remain_A5/${i}_withA10_remain_A5
done
```

Output files are stored in `~/zjw/20190105/3tail_read_with_tag_other_strand_withA10_remain_A5/`.

## Alignment

For alignment, we run:

```
for i in `ls ~/zjw/20190105/3tail_read_with_tag_other_strand_withA10_remain_A5/`
do
        STAR --runThreadN 24 --genomeDir ~/index/mm10_ERCC92trimpolyA_STAR/ --genomeLoad LoadAndKeep --readFilesIn ~/zjw/20190105/3tail_read_with_tag_other_strand_withA10_remain_A5/${i} --outFileNamePrefix ~/zjw/20190105/mapping_output/${i}_ --outSAMtype SAM --outFilterMultimapNmax 1 --outFilterScoreMinOverLread 0.6 --outFilterMatchNminOverLread 0.6
done
```

Output files are stored in `~/zjw/20190105/mapping_output/`.


## Extract uniquely mapped reads

We only select uniquely mapped reads, so we run:

```
for i in `ls ~/zjw/20190105/mapping_output/ |grep "sam"`
do
        samtools view ~/zjw/20190105/mapping_output/${i} | grep 'NH:i:1'$'\t''' > ~/zjw/20190105/extract_uniquely_map/${i}_extract_uniquely_map.sam
done
```

Output files are stored in `~/zjw/20190105/extract_uniquely_map/`.


## Split reads aligned to plus stand and minus strand

For further filter, we run:

```
for i in `ls ~/zjw/20190105/extract_uniquely_map | grep "sam"`
do
        cat ~/zjw/20190105/extract_uniquely_map/${i} | awk '{FS=" "}{if ($2==0 || $2==256){print $1"\t"$2"\t"$3"\t"$4"\t"$5"\t"$6"\t"$7"\t"$8"\t"$9"\t"$10"\t"$11"\t"$12"\t"$13"\t"$14"\t"$15}}' > ~/zjw/20190105/split_plus_minus/${i}_plus
        cat ~/zjw/20190105/extract_uniquely_map/${i} | awk '{FS=" "}{if ($2==16 || $2==272){print $1"\t"$2"\t"$3"\t"$4"\t"$5"\t"$6"\t"$7"\t"$8"\t"$9"\t"$10"\t"$11"\t"$12"\t"$13"\t"$14"\t"$15}}' > ~/zjw/20190105/split_plus_minus/${i}_minus
done
```

Output files are stored in `~/zjw/20190105/split_plus_minus/`.

## Extract reads with mismatch at 3'

We run:

```
for i in `ls ~/zjw/20190105/split_plus_minus | grep "extract_uniquely_map.sam_plus"`
do
        python ~/zjw/20190105/script_and_log/extractmismatch_plus_3'.py -i ~/zjw/20190105/split_plus_minus/${i} -o ~/zjw/20190105/extract_mismatch/${i}_extractmismatch
        python ~/zjw/20190105/script_and_log/extractmismatch_minus_3'.py -i ~/zjw/20190105/split_plus_minus/${i%_*}_minus -o ~/zjw/20190105/extract_mismatch/${i%_*}_minus_extractmismatch
        cat ~/zjw/20190105/extract_mismatch/${i}_extractmismatch ~/zjw/20190105/extract_mismatch/${i%_*}_minus_extractmismatch > ~/zjw/20190105/extract_mismatch/${i%_*}_extractmismatch
done
```

Oligo(dT) primers can also anneal to internal A-rich sequences, a phenomenon called internal priming, leading to the generation of artifact. If "AAAAA" aligned, reads are internal priming drivern artifacts. If "GGG" don't aligned, reads are supposed to contain true polyA site.

Output files are stored in `~/zjw/20190105/extract_mismatch/`.


## Convert SAM to BED

As BED format file can be used as input for CAGEr R package, we generate SAM to BED:

```
for i in `ls ~/zjw/20190105/extract_mismatch | grep "sam_extractmismatch"`
do
        samtools view -b -T ~/index/mm10_ERCC92/mm10_ERCC92trimpolyA.fa ~/zjw/20190105/extract_mismatch/${i} | samtools view -b >  ~/zjw/20190105/add_header/${i}.bam
        samtools sort ~/zjw/20190105/add_header/${i}.bam -o ~/zjw/20190105/add_header/${i}_sorted.bam
        samtools index ~/zjw/20190105/add_header/${i}_sorted.bam
        bedtools bamtobed -i ~/zjw/20190105/add_header/${i}_sorted.bam > ~/zjw/20190105/add_header/${i}.bed
done
```

Output files are stored in `~/zjw/20190105/add_header/`.

## Remove useless end

As the library is pair-end reads, we remove one side which doesn't contain TES information.

```
for i in `ls  ~/zjw/20190105/add_header |grep "TKD"|grep "bed"|grep "L1_1"`
do
        a=$(wc -l ~/zjw/20190105/add_header/${i}|awk '{print $1}')
        b=$(wc -l ~/zjw/20190105/add_header/${i%%L1_1*}L1_2.fq-common.out_withA10_remain_A5_Aligned.out.sam_extract_uniquely_map.sam_extractmismatch.bed|awk '{print $1}')
        echo ${a}
        echo ${b}
        if [ ${a} -gt ${b} ]; then
                rm ~/zjw/20190105/add_header/${i%%L1_1*}L1_2*
        else
                rm ~/zjw/20190105/add_header/${i%%L1_1*}L1_1*
        fi
done
```



